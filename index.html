<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Recoil Jet - Pop Star Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #2b2b40; /* Slightly purple dark bg */
            font-family: 'Fredoka One', cursive, sans-serif; /* Cute rounded font */
            touch-action: none;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            transition: transform 0.1s;
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            transform-origin: top center;
            transition: transform 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #score-group {
            text-align: left;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            border: 3px solid rgba(255, 255, 255, 0.5);
        }
        #altitude-display {
            color: #ffffff;
            font-size: 32px;
            text-shadow: 2px 2px 0 #444;
            letter-spacing: 1px;
        }
        #high-score-display {
            color: #ffee00;
            font-size: 16px;
            text-shadow: 1px 1px 0 #444;
        }
        #hp-display {
            font-size: 32px;
            color: #ff88bb;
            text-shadow: 2px 2px 0 #444;
            letter-spacing: 5px;
        }
        #heat-container {
            position: relative;
            width: 24px;
            height: 120px;
            border: 4px solid #fff;
            background: rgba(0,0,0,0.3);
            margin-top: 10px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }
        #heat-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background-color: #44ddff;
            transition: background-color 0.1s;
        }
        #magma-warning {
            position: absolute;
            bottom: 60px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #ff4444;
            font-size: 32px;
            text-shadow: 2px 2px 0 #fff;
            display: none;
            animation: bounce 0.5s infinite alternate;
        }
        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-10px); }
        }
        #power-text {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffff00;
            font-size: 50px;
            text-shadow: 4px 4px 0 #ff00aa;
            display: none;
            pointer-events: none;
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            70% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.0); opacity: 1; }
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(43, 43, 64, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }
        h1 {
            color: #44ddff;
            font-size: 48px;
            margin: 0 0 10px 0;
            text-shadow: 4px 4px 0 #2266aa;
            text-align: center;
            line-height: 1.1;
        }
        p {
            color: #fff;
            font-size: 18px;
            line-height: 1.8;
            text-align: center;
            max-width: 400px;
            background: rgba(255,255,255,0.1);
            padding: 25px;
            border-radius: 20px;
            border: 2px dashed rgba(255,255,255,0.3);
        }
        .start-btn {
            margin-top: 30px;
            color: #fff;
            background-color: #ff3366;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 6px 0 #aa2244;
            transition: transform 0.1s, box-shadow 0.1s;
            cursor: pointer;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
        }
        .start-btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #aa2244;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top" id="hud-top">
            <div id="score-group">
                <div id="altitude-display">0m</div>
                <div id="high-score-display">BEST: 0m</div>
            </div>
            <div style="display:flex; flex-direction:column; align-items:center;">
                <div id="hp-display">‚ù§‚ù§‚ù§</div>
                <div id="heat-container">
                    <div id="heat-fill"></div>
                </div>
            </div>
        </div>
        <div id="magma-warning">üî• RUN AWAY! üî•</div>
        <div id="power-text">HYPER JET!</div>
    </div>

    <div id="start-screen">
        <h1>RECOIL JET<br><span style="font-size:0.5em; color:#ff99cc;">Pop Star Edition</span></h1>
        <p>
            TAP & HOLD: <b>Shoot & Fly</b><br>
            RELEASE: <b>Spin & Aim</b><br><br>
            Defeat enemies for <b>HEARTS</b>!<br>
            Grab <b>‚ö°</b> for HYPER MODE!<br>
            Listen to the cute sounds üéµ
        </p>
        <div class="start-btn" onclick="startGame()">LET'S GO!</div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * RECOIL JET - POP STAR EDITION
 * Focus: Cute Audio, Pop Visuals, Fun Feedback
 */

const CONFIG = {
    gravity: 0.07,
    rotSpeed: 0.08,
    recoilForce: 2.1,
    shootRate: 6,
    heatRate: 2.5,
    coolRate: 3.0,
    maxHeat: 100,
    friction: 0.98,
    groundFriction: 0.85,
    cameraLerp: 0.1,
    magmaSpeedBase: 0.8,
    hitStopDuration: 6,
    coyoteTime: 10,
    colors: {
        player: '#44ddff',
        playerOutline: '#fff',
        bullet: '#fff',
        bulletPower: '#ffff00',
        enemy: '#ffbb00',
        enemyChaser: '#ff6666',
        platform: '#77dd77',
        platformSide: '#55aa55',
        hazard: '#aa44aa',
        bg: '#2b2b40',
        magma: '#ff5544',
        guideShoot: 'rgba(255, 255, 255, 0.2)',
        guideMove: 'rgba(68, 221, 255, 0.5)', 
        marker: '#ffff00',
        scarf: '#ffaa00'
    }
};

// --- CUTE AUDIO SYSTEM (Pop & Percussive) ---
const AudioSys = {
    ctx: null,
    bgmOsc: null,
    init: function() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone: function(type, freqStart, freqEnd, duration, vol) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freqStart, t);
        osc.frequency.linearRampToValueAtTime(freqEnd, t + duration);
        gain.gain.setValueAtTime(vol, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + duration);
    },
    // Cute "Poko Poko" rotation sound
    playSpin: function() {
        // Woodblock-like sound
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, t);
        osc.frequency.exponentialRampToValueAtTime(100, t + 0.05);
        gain.gain.setValueAtTime(0.05, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + 0.05);
    },
    playJump: function() {
        // "Pyun!"
        this.playTone('sine', 300, 800, 0.15, 0.1);
    },
    playPowerShoot: function() {
        // "Zyun!"
        this.playTone('square', 200, 600, 0.1, 0.05);
    },
    playLand: function() {
        // "Boing!"
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.linearRampToValueAtTime(250, t + 0.1);
        osc.frequency.linearRampToValueAtTime(150, t + 0.2);
        gain.gain.setValueAtTime(0.2, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.25);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + 0.3);
    },
    playCombo: function(count) {
        // Pitch rises with combo
        const pitch = 400 + (count * 100);
        this.playTone('square', pitch, pitch + 200, 0.1, 0.1);
    },
    playPop: function() {
        // "Pon!"
        this.playTone('triangle', 600, 100, 0.1, 0.1);
    },
    playDamage: function() {
        // "Bum..."
        this.playTone('sawtooth', 150, 50, 0.3, 0.2);
    },
    playHeal: function() {
        // "Pi-ro-lin!"
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        this.playToneAt(now, 523.25, 'sine');
        this.playToneAt(now + 0.05, 659.25, 'sine');
        this.playToneAt(now + 0.1, 783.99, 'sine');
        this.playToneAt(now + 0.15, 1046.50, 'sine');
    },
    playPowerUp: function() {
        // Fanfare
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        this.playToneAt(now, 440, 'triangle'); 
        this.playToneAt(now + 0.1, 554, 'triangle');
        this.playToneAt(now + 0.2, 659, 'triangle');
        this.playToneAt(now + 0.3, 880, 'triangle');
    },
    playToneAt: function(t, freq, type) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + 0.3);
    },
    playGem: function() {
        // "Kiran!"
        this.playTone('sine', 1000, 1500, 0.1, 0.1);
    }
};

// --- ENGINE ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let width, height;

// State
let gameState = 'START';
let altitude = 0;
let maxAltitude = 0;
let highScore = parseInt(localStorage.getItem('recoilJetHighAltitude')) || 0;
let frameCount = 0;
let hitStopFrames = 0;
let shakeIntensity = 0;
let floaters = [];
let comboCount = 0;
let comboTimer = 0;
let hudBounce = 1.0;

const input = { active: false };
const startEvents = ['mousedown', 'touchstart', 'keydown'];
const endEvents = ['mouseup', 'touchend', 'keyup'];

function handleInputStart(e) {
    if (e.type === 'keydown' && e.code !== 'Space') return;
    if (e.type === 'touchstart') e.preventDefault();
    input.active = true;
    if (gameState === 'GAMEOVER') startGame();
}
function handleInputEnd() { input.active = false; }
startEvents.forEach(evt => window.addEventListener(evt, handleInputStart, { passive: false }));
endEvents.forEach(evt => window.addEventListener(evt, handleInputEnd));

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    document.getElementById('high-score-display').innerText = `BEST: ${Math.floor(highScore)}m`;
}
window.addEventListener('resize', resize);
resize();

// --- ENTITIES ---

class Scarf {
    constructor(length) {
        this.nodes = [];
        this.length = length;
        for (let i = 0; i < length; i++) this.nodes.push({ x: 0, y: 0 });
    }
    update(headX, headY) {
        this.nodes[0] = { x: headX, y: headY };
        for (let i = 1; i < this.length; i++) {
            let prev = this.nodes[i-1];
            let curr = this.nodes[i];
            let dx = prev.x - curr.x;
            let dy = prev.y - curr.y;
            curr.x += dx * 0.3; 
            curr.y += dy * 0.3;
            curr.y += 0.5;
        }
    }
    draw(ctx, isPower) {
        ctx.beginPath();
        ctx.moveTo(this.nodes[0].x, this.nodes[0].y);
        for (let i = 1; i < this.length; i++) {
             const xc = (this.nodes[i].x + this.nodes[i - 1].x) / 2;
             const yc = (this.nodes[i].y + this.nodes[i - 1].y) / 2;
             ctx.quadraticCurveTo(this.nodes[i - 1].x, this.nodes[i - 1].y, xc, yc);
        }
        ctx.lineTo(this.nodes[this.length-1].x, this.nodes[this.length-1].y);
        
        if (isPower) {
            // Rainbow Scarf
            const grad = ctx.createLinearGradient(this.nodes[0].x, this.nodes[0].y, this.nodes[this.length-1].x, this.nodes[this.length-1].y);
            grad.addColorStop(0, `hsl(${frameCount * 10}, 100%, 50%)`);
            grad.addColorStop(1, `hsl(${frameCount * 10 + 180}, 100%, 50%)`);
            ctx.strokeStyle = grad;
            ctx.lineWidth = 8;
        } else {
            ctx.strokeStyle = CONFIG.colors.scarf;
            ctx.lineWidth = 6;
        }
        
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}

class Player {
    constructor() {
        this.x = width / 2;
        this.y = height / 2;
        this.vx = 0;
        this.vy = 0;
        this.angle = -Math.PI / 2;
        this.radius = 18;
        this.heat = 0;
        this.hp = 3;
        this.maxHp = 3;
        this.overheated = false;
        this.invincible = 0;
        this.grounded = false;
        this.dead = false;
        this.scaleX = 1;
        this.scaleY = 1;
        this.scarf = new Scarf(12);
        this.powerMode = 0;
        this.spinSoundTimer = 0; // Timer for cute spin sound
    }

    update() {
        if (this.dead) return;

        if (!this.grounded) {
            this.vy += CONFIG.gravity;
        }

        const canShoot = input.active && !this.overheated;

        if (canShoot) {
            this.heat += CONFIG.heatRate;
            this.grounded = false;
            if (this.heat >= CONFIG.maxHeat) {
                this.overheated = true;
                this.heat = CONFIG.maxHeat;
                setTimeout(() => { this.overheated = false; }, 1000);
            }
            if (frameCount % CONFIG.shootRate === 0) this.shoot();
        } else {
            // Idle / Spinning
            this.angle += CONFIG.rotSpeed;
            this.heat = Math.max(0, this.heat - CONFIG.coolRate);
            
            // Cute spin sound rhythm (only when grounded or slow)
            if (this.grounded) {
                this.spinSoundTimer++;
                if (this.spinSoundTimer > 15) { // "Poko... Poko..."
                    AudioSys.playSpin();
                    this.spinSoundTimer = 0;
                    this.scaleY = 0.9; // Little bounce
                    this.scaleX = 1.1;
                }
            }
        }

        const fric = this.grounded ? CONFIG.groundFriction : CONFIG.friction;
        this.vx *= fric;
        const restore = this.grounded ? 0.2 : 0.1;
        this.scaleX += (1 - this.scaleX) * restore;
        this.scaleY += (1 - this.scaleY) * restore;

        if (!this.grounded) this.vy *= CONFIG.friction;

        this.x += this.vx;
        this.y += this.vy;

        if (this.x < this.radius) { this.x = this.radius; this.vx *= -0.6; }
        if (this.x > width - this.radius) { this.x = width - this.radius; this.vx *= -0.6; }

        this.scarf.update(this.x, this.y);
        if (this.invincible > 0) this.invincible--;
        if (this.powerMode > 0) this.powerMode--;
        
        this.updateUI();
    }
    
    updateUI() {
        let hearts = "";
        for(let i=0; i<this.maxHp; i++) hearts += (i < this.hp) ? "‚ù§" : "‚ô°";
        document.getElementById('hp-display').innerText = hearts;
        
        const fill = document.getElementById('heat-fill');
        fill.style.height = `${(this.heat / CONFIG.maxHeat) * 100}%`;
        fill.style.backgroundColor = this.overheated ? '#ff3333' : '#44ddff';
        
        if (this.powerMode > 0) {
            fill.style.backgroundColor = `hsl(${frameCount * 20}, 100%, 70%)`; // Pastel rainbow
        }
    }

    shoot() {
        const isPower = this.powerMode > 0;
        const muzzleX = this.x + Math.cos(this.angle) * (this.radius + 8);
        const muzzleY = this.y + Math.sin(this.angle) * (this.radius + 8);
        bullets.push(new Bullet(muzzleX, muzzleY, this.angle, isPower));
        
        const boost = isPower ? 1.5 : 1.0;
        const force = CONFIG.recoilForce * boost;
        
        this.vx -= Math.cos(this.angle) * force;
        this.vy -= Math.sin(this.angle) * force;

        this.scaleY = 1.3; this.scaleX = 0.8; 
        addShake(isPower ? 5 : 2);
        particles.push(new Particle(muzzleX, muzzleY, this.angle, 'puff'));
        
        if(isPower) AudioSys.playPowerShoot();
        else AudioSys.playJump();
    }

    land() {
        if (!this.grounded) {
            this.grounded = true;
            this.vy = 0;
            this.scaleY = 0.6; this.scaleX = 1.4;
            hudBounce = 1.15; 
            AudioSys.playLand();
            for(let i=0; i<5; i++) particles.push(new Particle(this.x+(Math.random()-0.5)*20, this.y+this.radius, -Math.PI/2, 'puff'));
        }
    }

    heal() {
        if (this.hp < this.maxHp) {
            this.hp++;
            floaters.push(new Floater(this.x, this.y - 20, "HEAL!", '#ff99cc'));
            AudioSys.playHeal();
            hudBounce = 1.2;
        } else {
            floaters.push(new Floater(this.x, this.y - 20, "BONUS!", '#ffff00'));
            AudioSys.playGem();
        }
    }
    
    activatePower() {
        this.powerMode = 600; 
        this.invincible = 600; 
        floaters.push(new Floater(this.x, this.y - 40, "HYPER!", '#ffff00'));
        
        const pt = document.getElementById('power-text');
        pt.style.display = 'block';
        pt.style.animation = 'none';
        pt.offsetHeight; 
        pt.style.animation = 'popIn 1.5s ease-out forwards';
        
        AudioSys.playPowerUp();
        hudBounce = 1.3;
    }

    takeDamage() {
        if (this.invincible > 0 || this.dead) return;
        this.hp--;
        this.invincible = 60;
        addShake(15);
        hudBounce = 0.9;
        AudioSys.playDamage();
        if (this.hp <= 0) {
            this.dead = true;
            gameOver();
        } else {
            this.vy = -5;
        }
    }

    draw(ctx) {
        if (this.dead) return;
        if (this.invincible > 0 && this.powerMode <= 0 && Math.floor(frameCount / 4) % 2 === 0) return;

        this.scarf.draw(ctx, this.powerMode > 0);

        // Guides
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - Math.cos(this.angle) * 150, this.y - Math.sin(this.angle) * 150);
        ctx.strokeStyle = CONFIG.colors.guideMove;
        ctx.lineWidth = 4;
        ctx.setLineDash([10, 10]);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scaleX, this.scaleY);
        ctx.rotate(this.angle + Math.PI/2); 

        // Body
        ctx.fillStyle = (this.powerMode > 0 && frameCount%4 < 2) ? '#ffffff' : CONFIG.colors.player;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = CONFIG.colors.playerOutline;
        ctx.lineWidth = 3;
        ctx.stroke();

        // Goggles (Cute Eyes)
        ctx.fillStyle = '#333';
        ctx.fillRect(-18, -4, 36, 6);
        ctx.fillStyle = '#ffaa00';
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(-7, -1, 7, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.arc(7, -1, 7, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = 'white';
        // Eye shine
        ctx.beginPath(); ctx.arc(-9, -3, 3, 0, Math.PI*2); ctx.arc(5, -3, 3, 0, Math.PI*2); ctx.fill();

        // HELMET / ANTENNA
        ctx.beginPath();
        ctx.arc(0, -2, 19, Math.PI, 0); 
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#fff';
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, -19);
        ctx.lineTo(0, -32);
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#ccc';
        ctx.stroke();
        
        ctx.fillStyle = (this.powerMode > 0) ? '#ffff00' : '#ff3366';
        ctx.beginPath();
        ctx.arc(0, -32, 5, 0, Math.PI*2); // Bigger ball
        ctx.fill();

        ctx.restore();
    }
}

class Platform {
    constructor(x, y, w) {
        this.x = x; this.y = y; this.w = w; this.h = 26;
    }
    draw(ctx) {
        ctx.fillStyle = CONFIG.colors.platformSide;
        ctx.beginPath(); ctx.roundRect(this.x, this.y, this.w, this.h, 12); ctx.fill();
        ctx.fillStyle = CONFIG.colors.platform;
        ctx.beginPath(); ctx.roundRect(this.x, this.y, this.w, 12, 6); ctx.fill();
        
        // Cute decoration
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath(); ctx.arc(this.x + 15, this.y + 15, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(this.x + this.w - 15, this.y + 15, 3, 0, Math.PI*2); ctx.fill();
    }
}

class HazardWall {
    constructor(x, y, w, h) {
        this.x = x; this.y = y; this.w = w; this.h = h;
    }
    draw(ctx) {
        ctx.fillStyle = '#440044';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        if (Math.floor(frameCount/5)%2 === 0) {
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 3;
            ctx.strokeRect(this.x+2, this.y+2, this.w-4, this.h-4);
        }
        ctx.strokeStyle = '#aa00aa';
        ctx.strokeRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = '#ff00ff';
        ctx.textAlign = 'center';
        ctx.font = '24px Arial';
        ctx.fillText("‚ö°", this.x + this.w/2, this.y + this.h/2 + 8);
    }
}

class Item {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; 
        this.vy = -4; 
        this.vx = (Math.random() - 0.5) * 4;
        this.life = 400; 
        this.angle = 0;
    }
    update() {
        this.vy += 0.2; 
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.95;
        this.life--;
        this.angle += 0.1;
    }
    draw(ctx) {
        if (this.life < 60 && Math.floor(this.life/4)%2===0) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.translate(0, Math.sin(this.life * 0.1) * 5);
        
        if (this.type === 'heart') {
            ctx.fillStyle = '#ff3366';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("‚ù§", 0, 10);
        } else if (this.type === 'power') {
            ctx.fillStyle = '#ffff00';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffff00';
            ctx.fillText("‚ö°", 0, 10);
            ctx.shadowBlur = 0;
        } else {
            ctx.fillStyle = '#00ffff';
            ctx.rotate(this.angle);
            ctx.fillRect(-8, -8, 16, 16); // Gem
        }
        ctx.restore();
    }
}

class Bullet {
    constructor(x, y, angle, isPower) {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * (isPower ? 20 : 14); 
        this.vy = Math.sin(angle) * (isPower ? 20 : 14);
        this.life = isPower ? 60 : 40;
        this.isPower = isPower;
        this.radius = isPower ? 14 : 7;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw(ctx) {
        ctx.fillStyle = this.isPower ? CONFIG.colors.bulletPower : CONFIG.colors.bullet;
        ctx.beginPath(); 
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); 
        ctx.fill();
        if (this.isPower) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffff00';
            ctx.strokeStyle = '#fff';
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
    }
}

class Enemy {
    constructor(y, type) {
        this.x = Math.random() * (width - 60) + 30;
        this.y = y;
        this.type = type; 
        this.radius = 20;
        this.hp = 1;
        if (type === 1) this.hp = 2;
        this.angle = 0;
        this.startX = this.x;
        this.startY = this.y;
        this.offset = Math.random() * 100;
        this.time = 0;
    }
    update(playerX, playerY) {
        this.time++;
        if (this.type === 0) {
            this.angle += 0.05;
            this.x = this.startX + Math.sin(this.angle * 2 + this.offset) * 60;
        } else if (this.type === 1) {
            const dx = playerX - this.x;
            const dy = playerY - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 350) { 
                this.x += (dx / dist) * 1.5;
                this.y += (dy / dist) * 1.5;
            }
            this.angle += 0.1;
        } else if (this.type === 2) {
            this.x = this.startX + Math.sin(this.time * 0.1) * 120;
            this.y = this.startY + Math.cos(this.time * 0.05) * 30;
            this.angle -= 0.1;
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = (this.type === 1) ? CONFIG.colors.enemyChaser : CONFIG.colors.enemy;
        
        // Wobble scale
        const scale = 1.0 + Math.sin(this.time * 0.2) * 0.1;
        ctx.scale(scale, scale);

        ctx.beginPath();
        const spikes = (this.type === 1) ? 12 : 8;
        // Rounded spikes (Cute!)
        for(let i=0; i<spikes; i++) {
            let rot = this.angle + (i * Math.PI * 2) / spikes;
            let r = this.radius;
            let rIn = this.radius * 0.7;
            ctx.lineTo(Math.cos(rot)*r, Math.sin(rot)*r);
            // Mid point
            let rotMid = rot + (Math.PI/spikes);
            ctx.lineTo(Math.cos(rotMid)*rIn, Math.sin(rotMid)*rIn);
        }
        ctx.closePath();
        ctx.fill();
        
        // Eyes (Googly)
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(-6, -6, 6, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(6, -6, 6, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = '#000';
        // Eye pupils moving
        const eyeX = Math.cos(this.time * 0.1) * 2;
        const eyeY = Math.sin(this.time * 0.1) * 2;
        ctx.beginPath(); ctx.arc(-6 + eyeX, -6 + eyeY, 2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(6 + eyeX, -6 + eyeY, 2, 0, Math.PI*2); ctx.fill();

        ctx.restore();
    }
}

class Particle {
    constructor(x, y, angle, type) {
        this.x = x; this.y = y; this.life = 1.0; this.type = type;
        const speed = (type === 'puff') ? 2 : 5;
        this.vx = (Math.random()-0.5)*speed; this.vy = (Math.random()-0.5)*speed;
        this.decay = (type === 'puff') ? 0.08 : 0.05;
        this.color = (type === 'puff') ? '#fff' : CONFIG.colors.enemy;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life -= this.decay; }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, (this.type === 'puff') ? 8 : 5, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Floater {
    constructor(x, y, text, color) {
        this.x = x; this.y = y; this.text = text; this.life = 50; this.color = color || 'white';
        this.vy = -2;
    }
    update() { this.y += this.vy; this.life--; }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life/50;
        ctx.font = 'bold 24px Fredoka One';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1;
    }
}

// --- GLOBALS ---
let player;
let bullets = [];
let enemies = [];
let platforms = [];
let hazards = [];
let items = [];
let particles = [];
let magmaY = 0;
let cameraY = 0;
let levelGenY = 0;

function addShake(amt) { shakeIntensity = Math.min(shakeIntensity + amt, 20); }

function saveHighScore() {
    if (Math.floor(maxAltitude) > highScore) {
        highScore = Math.floor(maxAltitude);
        localStorage.setItem('recoilJetHighAltitude', highScore);
        document.getElementById('high-score-display').innerText = `BEST: ${highScore}m`;
    }
}

function generateLevel() {
    while (levelGenY > cameraY - height * 2) {
        const gap = 110; 
        levelGenY -= gap; 
        
        const rand = Math.random();
        const w = 150 + Math.random() * 150;
        const x = Math.random() * (width - w);

        const currentHeight = Math.abs(levelGenY);
        let enemyChance = 0.4;
        let hazardChance = 0.2;

        if (currentHeight < 1000) { enemyChance = 0; hazardChance = 0; }

        if (rand < hazardChance) {
             hazards.push(new HazardWall(x, levelGenY, 100, 30));
        } else if (rand < hazardChance + enemyChance) {
             let type = 0;
             if (currentHeight > 3000 && Math.random() > 0.7) type = 1; 
             if (currentHeight > 5000 && Math.random() > 0.5) type = 2; 
             enemies.push(new Enemy(levelGenY, type));
        } else {
             platforms.push(new Platform(x, levelGenY, w));
        }
    }
    
    const delY = cameraY + height + 200;
    enemies = enemies.filter(e => e.y < delY);
    platforms = platforms.filter(p => p.y < delY);
    hazards = hazards.filter(h => h.y < delY);
    items = items.filter(i => i.y < delY);
}

function startGame() {
    AudioSys.init();
    player = new Player();
    bullets = [];
    enemies = [];
    platforms = [];
    hazards = [];
    items = [];
    particles = [];
    floaters = [];
    altitude = 0;
    maxAltitude = 0;
    frameCount = 0;
    magmaY = height + 800; 
    cameraY = 0;
    levelGenY = -200;
    hudBounce = 1.0;
    comboCount = 0;
    
    platforms.push(new Platform(width/2 - 100, height/2 + 100, 200));

    gameState = 'PLAY';
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('magma-warning').style.display = 'none';
    document.getElementById('power-text').style.display = 'none';
    gameLoop();
}

function gameOver() {
    gameState = 'GAMEOVER';
    saveHighScore();
    AudioSys.playDamage();
    document.getElementById('start-screen').style.display = 'flex';
    document.querySelector('#start-screen h1').innerText = "GAME OVER";
    document.querySelector('#start-screen p').innerHTML = 
        `REACHED: ${Math.floor(maxAltitude)}m<br>BEST: ${highScore}m`;
    // Change button text
    document.querySelector('.start-btn').innerText = "TRY AGAIN";
}

function update() {
    if (hitStopFrames > 0) { hitStopFrames--; return; }

    hudBounce += (1.0 - hudBounce) * 0.1;
    document.getElementById('hud-top').style.transform = `scale(${hudBounce})`;

    // Combo Reset
    if (comboTimer > 0) comboTimer--;
    else comboCount = 0;

    const targetOffset = height * 0.7; 
    const targetCamY = player.y - targetOffset;
    cameraY += (targetCamY - cameraY) * CONFIG.cameraLerp;
    
    altitude = Math.abs(Math.min(0, player.y)) / 10;
    maxAltitude = Math.max(maxAltitude, altitude);

    let magmaSpeed = CONFIG.magmaSpeedBase + (altitude / 5000); 
    if (player.y > magmaY - 300) magmaSpeed *= 0.5; 
    magmaY -= magmaSpeed;

    const dist = magmaY - player.y;
    const warn = document.getElementById('magma-warning');
    if (dist < 500 && !player.dead) {
        warn.style.display = 'block';
        warn.style.opacity = 1 - (dist/500);
    } else { warn.style.display = 'none'; }

    if (player.y > magmaY) { player.dead = true; gameOver(); }

    player.update();

    player.grounded = false;
    platforms.forEach(p => {
        if (player.vy >= 0 &&
            player.y + player.radius >= p.y &&
            player.y - player.radius < p.y + p.h &&
            player.x > p.x && player.x < p.x + p.w)
        {
             if ((player.y + player.radius) - p.y < 30) { 
                 player.y = p.y - player.radius;
                 player.land();
             }
        }
    });

    hazards.forEach(h => {
        if (player.x > h.x && player.x < h.x + h.w &&
            player.y > h.y && player.y < h.y + h.h) {
                player.takeDamage();
                player.vy = 10;
        }
    });

    bullets.forEach((b, i) => {
        b.update();
        if (b.life<=0) { bullets.splice(i,1); return; }
        
        for(let j=enemies.length-1; j>=0; j--) {
            let e = enemies[j];
            const dist = Math.hypot(b.x-e.x, b.y-e.y);
            const hitRadius = e.radius + (b.isPower ? 20 : 10);
            
            if (dist < hitRadius) {
                e.hp -= (b.isPower ? 10 : 1); 
                if (!b.isPower) bullets.splice(i,1); 
                
                AudioSys.playPop();
                if(e.hp<=0) {
                    enemies.splice(j,1);
                    hitStopFrames = b.isPower ? 6 : 3;
                    if(b.isPower) addShake(5);
                    
                    // COMBO SYSTEM
                    comboCount++;
                    comboTimer = 120; // 2 seconds to chain
                    AudioSys.playCombo(Math.min(comboCount, 10));
                    floaters.push(new Floater(e.x, e.y, `${comboCount} HIT!`, '#ffaa00'));
                    
                    for(let k=0; k<5; k++) particles.push(new Particle(e.x, e.y, 0, 'debris'));
                    
                    const rand = Math.random();
                    if (rand < 0.25) items.push(new Item(e.x, e.y, 'heart'));
                    else if (rand < 0.45) items.push(new Item(e.x, e.y, 'gem'));
                    else if (rand < 0.50) items.push(new Item(e.x, e.y, 'power'));
                }
                break;
            }
        }
    });

    items.forEach((it, i) => {
        it.update();
        if (it.life <= 0) { items.splice(i, 1); return; }
        
        if (Math.hypot(player.x - it.x, player.y - it.y) < player.radius + 15) {
            if (it.type === 'heart') player.heal();
            else if (it.type === 'power') player.activatePower();
            else {
                floaters.push(new Floater(it.x, it.y - 20, "NICE!", '#00ffff'));
                AudioSys.playGem();
            }
            items.splice(i, 1);
        }
    });

    enemies.forEach(e => {
        e.update(player.x, player.y);
        if (Math.hypot(player.x-e.x, player.y-e.y) < player.radius + e.radius) {
            if (player.powerMode > 0) {
                enemies = enemies.filter(en => en !== e);
                AudioSys.playPop();
                addShake(5);
                floaters.push(new Floater(e.x, e.y, "CRUSH!", '#ffff00'));
                for(let k=0; k<8; k++) particles.push(new Particle(e.x, e.y, 0, 'debris'));
            } else {
                player.takeDamage();
                player.vx = (player.x - e.x) * 0.2;
                player.vy = -5;
            }
        }
    });

    particles.forEach((p, i) => {
        p.update(); if(p.life<=0) particles.splice(i,1);
    });
    floaters.forEach((f, i) => {
        f.update(); if(f.life<=0) floaters.splice(i,1);
    });

    generateLevel();
    frameCount++;
}

function findNextTarget() {
    let best = null;
    let minDist = Infinity;
    platforms.forEach(p => {
        if (p.y < player.y - 50) {
            const dy = player.y - p.y;
            if (dy < minDist) { minDist = dy; best = p; }
        }
    });
    return best;
}

function draw() {
    ctx.fillStyle = CONFIG.colors.bg;
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    let shakeX = (Math.random()-0.5) * shakeIntensity;
    let shakeY = (Math.random()-0.5) * shakeIntensity;
    shakeIntensity *= 0.9;
    if (Math.abs(shakeIntensity)<0.5) shakeIntensity = 0;
    
    ctx.translate(shakeX, shakeY - cameraY);

    ctx.fillStyle = CONFIG.colors.magma;
    ctx.fillRect(0, magmaY, width, height*3);
    ctx.fillStyle = '#ff5544';
    ctx.beginPath();
    for(let i=0; i<=width; i+=20) ctx.lineTo(i, magmaY + Math.sin(frameCount*0.1 + i*0.05)*20);
    ctx.lineTo(width, magmaY+50); ctx.lineTo(0, magmaY+50);
    ctx.fill();

    platforms.forEach(p => p.draw(ctx));
    hazards.forEach(h => h.draw(ctx));
    enemies.forEach(e => e.draw(ctx));
    items.forEach(i => i.draw(ctx));
    particles.forEach(p => p.draw(ctx));
    bullets.forEach(b => b.draw(ctx));
    player.draw(ctx);
    floaters.forEach(f => f.draw(ctx));

    const target = findNextTarget();
    if (target) {
        const tx = target.x + target.w / 2;
        const ty = target.y;
        const screenY = ty - cameraY;
        if (screenY < 0) {
            ctx.restore(); 
            ctx.save();
            const indicatorX = Math.max(20, Math.min(width-20, tx));
            ctx.translate(indicatorX, 30);
            ctx.translate(0, Math.sin(frameCount * 0.2) * 5);
            ctx.fillStyle = CONFIG.colors.marker;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-10, 10);
            ctx.lineTo(10, 10);
            ctx.fill();
            ctx.font = 'bold 16px Fredoka One';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.fillText("NEXT", 0, 30);
            ctx.restore();
            return; 
        }
    }

    ctx.restore();
    
    document.getElementById('altitude-display').innerText = `${Math.floor(altitude)}m`;
}

function gameLoop() {
    if (gameState === 'PLAY') {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }
}

ctx.fillStyle = '#2b2b40';
ctx.fillRect(0, 0, width, height);
</script>
</body>
</html>
