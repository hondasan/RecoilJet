<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Recoil Jet - Sky Pilot Final</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Verdana', sans-serif;
            touch-action: none;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            transition: transform 0.1s;
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            transform-origin: top center;
            transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #score-group {
            text-align: left;
        }
        #altitude-display {
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }
        #high-score-display {
            color: #ffff00;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }
        #hp-display {
            font-size: 28px;
            color: #ff99cc;
            text-shadow: 2px 2px 0 #000;
            letter-spacing: 2px;
        }
        #heat-container {
            position: relative;
            width: 20px;
            height: 100px;
            border: 3px solid #fff;
            background: rgba(0,0,0,0.5);
            margin-top: 10px;
            border-radius: 10px;
            overflow: hidden;
        }
        #heat-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background-color: #44ddff;
            transition: background-color 0.1s;
        }
        #magma-warning {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #ff2200;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff0000;
            display: none;
            animation: blinker 0.2s linear infinite;
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }
        h1 {
            color: #44ddff;
            font-size: 36px;
            margin: 0 0 10px 0;
            text-shadow: 3px 3px 0 #fff;
            text-align: center;
        }
        p {
            color: #fff;
            font-size: 16px;
            line-height: 1.6;
            text-align: center;
            max-width: 400px;
            background: rgba(0,0,0,0.6);
            padding: 20px;
            border-radius: 10px;
        }
        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top" id="hud-top">
            <div id="score-group">
                <div id="altitude-display">0m</div>
                <div id="high-score-display">BEST: 0m</div>
            </div>
            <div style="display:flex; flex-direction:column; align-items:center;">
                <div id="hp-display">❤❤❤</div>
                <div id="heat-container">
                    <div id="heat-fill"></div>
                </div>
            </div>
        </div>
        <div id="magma-warning">⚠ MAGMA RISING ⚠</div>
    </div>

    <div id="start-screen">
        <h1>RECOIL JET<br><span style="font-size:0.6em; color:white;">Sky Pilot Final</span></h1>
        <p>
            TAP & HOLD: <b>Shoot & Fly</b><br>
            RELEASE: <b>Spin & Aim</b><br><br>
            Destroy enemies to get <b>HEARTS</b>!<br>
            Avoid the <b>Electrical Walls</b>.<br>
            Magma is fast. Keep climbing!
        </p>
        <p class="blink" style="margin-top: 20px; color: #44ddff; font-weight: bold; font-size: 20px;">[ TAP TO START ]</p>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * RECOIL JET - SKY PILOT EDITION (FINAL)
 * Changes:
 * - Faster Magma (0.8 base)
 * - Item Drops (Heart/Star) on enemy kill
 * - New Enemy Types (Chaser, Zigzag)
 * - Hazard Walls (Electric)
 * - Cute Sounds (Sine/Triangle waves)
 * - High Score based on Altitude
 */

const CONFIG = {
    gravity: 0.07,
    rotSpeed: 0.05,
    recoilForce: 2.1,
    shootRate: 6,
    heatRate: 2.5,
    coolRate: 3.0,
    maxHeat: 100,
    friction: 0.98,
    groundFriction: 0.85,
    cameraLerp: 0.1,
    magmaSpeedBase: 0.8,    // FASTER!
    hitStopDuration: 6,
    coyoteTime: 10,
    colors: {
        player: '#44ddff',
        playerOutline: '#fff',
        bullet: '#fff',
        enemy: '#ffcc00',
        enemyChaser: '#ff5555',
        platform: '#66cc66',
        hazard: '#cc33ff',
        bg: '#222',
        magma: '#ff4400',
        guideShoot: 'rgba(255, 255, 255, 0.2)',
        guideMove: 'rgba(68, 221, 255, 0.5)', 
        marker: '#ffff00',
        scarf: '#ffaa00'
    }
};

// --- CUTE AUDIO SYSTEM ---
const AudioSys = {
    ctx: null,
    init: function() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    // Helper for cute blips
    playTone: function(type, freqStart, freqEnd, duration, vol) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freqStart, t);
        osc.frequency.linearRampToValueAtTime(freqEnd, t + duration);
        gain.gain.setValueAtTime(vol, t);
        gain.gain.linearRampToValueAtTime(0, t + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + duration);
    },
    playJump: function() {
        this.playTone('sine', 250, 600, 0.15, 0.1);
    },
    playLand: function() {
        // "Boing" sound
        this.playTone('triangle', 150, 250, 0.2, 0.15);
    },
    playPop: function() {
        this.playTone('square', 400, 100, 0.1, 0.1);
    },
    playDamage: function() {
        this.playTone('sawtooth', 150, 50, 0.3, 0.2);
    },
    playHeal: function() {
        // "Pi-ro-lin!" Arpeggio
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        this.playToneAt(now, 523.25, 'sine'); // C5
        this.playToneAt(now + 0.05, 659.25, 'sine'); // E5
        this.playToneAt(now + 0.1, 783.99, 'sine'); // G5
        this.playToneAt(now + 0.15, 1046.50, 'sine'); // C6
    },
    playToneAt: function(t, freq, type) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + 0.1);
    },
    playGem: function() {
        this.playTone('sine', 880, 1200, 0.1, 0.1);
    }
};

// --- ENGINE ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let width, height;

// State
let gameState = 'START';
let altitude = 0; // Current Altitude (m)
let maxAltitude = 0; // Max achieved this run
let highScore = parseInt(localStorage.getItem('recoilJetHighAltitude')) || 0;
let frameCount = 0;
let hitStopFrames = 0;
let shakeIntensity = 0;
let floaters = [];

// UI Bouncing State
let hudBounce = 1.0;

const input = { active: false };
const startEvents = ['mousedown', 'touchstart', 'keydown'];
const endEvents = ['mouseup', 'touchend', 'keyup'];

function handleInputStart(e) {
    if (e.type === 'keydown' && e.code !== 'Space') return;
    if (e.type === 'touchstart') e.preventDefault();
    input.active = true;
    if (gameState === 'START' || gameState === 'GAMEOVER') startGame();
}
function handleInputEnd() { input.active = false; }
startEvents.forEach(evt => window.addEventListener(evt, handleInputStart, { passive: false }));
endEvents.forEach(evt => window.addEventListener(evt, handleInputEnd));

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    document.getElementById('high-score-display').innerText = `BEST: ${Math.floor(highScore)}m`;
}
window.addEventListener('resize', resize);
resize();

// --- ENTITIES ---

class Scarf {
    constructor(length) {
        this.nodes = [];
        this.length = length;
        for (let i = 0; i < length; i++) this.nodes.push({ x: 0, y: 0 });
    }
    update(headX, headY) {
        this.nodes[0] = { x: headX, y: headY };
        for (let i = 1; i < this.length; i++) {
            let prev = this.nodes[i-1];
            let curr = this.nodes[i];
            let dx = prev.x - curr.x;
            let dy = prev.y - curr.y;
            curr.x += dx * 0.3; 
            curr.y += dy * 0.3;
            curr.y += 0.5;
        }
    }
    draw(ctx) {
        ctx.beginPath();
        ctx.moveTo(this.nodes[0].x, this.nodes[0].y);
        for (let i = 1; i < this.length; i++) {
             const xc = (this.nodes[i].x + this.nodes[i - 1].x) / 2;
             const yc = (this.nodes[i].y + this.nodes[i - 1].y) / 2;
             ctx.quadraticCurveTo(this.nodes[i - 1].x, this.nodes[i - 1].y, xc, yc);
        }
        ctx.lineTo(this.nodes[this.length-1].x, this.nodes[this.length-1].y);
        ctx.strokeStyle = CONFIG.colors.scarf;
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}

class Player {
    constructor() {
        this.x = width / 2;
        this.y = height / 2;
        this.vx = 0;
        this.vy = 0;
        this.angle = -Math.PI / 2;
        this.radius = 18;
        this.heat = 0;
        this.hp = 3;
        this.maxHp = 3;
        this.overheated = false;
        this.invincible = 0;
        this.grounded = false;
        this.dead = false;
        this.scaleX = 1;
        this.scaleY = 1;
        this.scarf = new Scarf(10);
    }

    update() {
        if (this.dead) return;

        if (!this.grounded) {
            this.vy += CONFIG.gravity;
        }

        const canShoot = input.active && !this.overheated;

        if (canShoot) {
            this.heat += CONFIG.heatRate;
            this.grounded = false;
            if (this.heat >= CONFIG.maxHeat) {
                this.overheated = true;
                this.heat = CONFIG.maxHeat;
                setTimeout(() => { this.overheated = false; }, 1000);
            }
            if (frameCount % CONFIG.shootRate === 0) this.shoot();
        } else {
            this.angle += CONFIG.rotSpeed;
            this.heat = Math.max(0, this.heat - CONFIG.coolRate);
        }

        // Physics
        const fric = this.grounded ? CONFIG.groundFriction : CONFIG.friction;
        this.vx *= fric;
        // Squash & Stretch return
        const restore = this.grounded ? 0.2 : 0.1;
        this.scaleX += (1 - this.scaleX) * restore;
        this.scaleY += (1 - this.scaleY) * restore;

        // Air drag
        if (!this.grounded) this.vy *= CONFIG.friction;

        this.x += this.vx;
        this.y += this.vy;

        // Walls
        if (this.x < this.radius) { this.x = this.radius; this.vx *= -0.6; }
        if (this.x > width - this.radius) { this.x = width - this.radius; this.vx *= -0.6; }

        this.scarf.update(this.x, this.y);
        if (this.invincible > 0) this.invincible--;
        this.updateUI();
    }
    
    updateUI() {
        let hearts = "";
        for(let i=0; i<this.maxHp; i++) hearts += (i < this.hp) ? "❤" : "♡";
        document.getElementById('hp-display').innerText = hearts;
        
        const fill = document.getElementById('heat-fill');
        fill.style.height = `${(this.heat / CONFIG.maxHeat) * 100}%`;
        fill.style.backgroundColor = this.overheated ? '#ff3333' : '#44ddff';
    }

    shoot() {
        const muzzleX = this.x + Math.cos(this.angle) * (this.radius + 8);
        const muzzleY = this.y + Math.sin(this.angle) * (this.radius + 8);
        bullets.push(new Bullet(muzzleX, muzzleY, this.angle));
        
        this.vx -= Math.cos(this.angle) * CONFIG.recoilForce;
        this.vy -= Math.sin(this.angle) * CONFIG.recoilForce;

        this.scaleY = 1.3; this.scaleX = 0.8; 
        addShake(2);
        particles.push(new Particle(muzzleX, muzzleY, this.angle, 'puff'));
        AudioSys.playJump();
    }

    land() {
        if (!this.grounded) {
            this.grounded = true;
            this.vy = 0;
            this.scaleY = 0.6; this.scaleX = 1.4;
            hudBounce = 1.15; // UI Bounce
            AudioSys.playLand();
            for(let i=0; i<5; i++) particles.push(new Particle(this.x+(Math.random()-0.5)*20, this.y+this.radius, -Math.PI/2, 'puff'));
        }
    }

    heal() {
        if (this.hp < this.maxHp) {
            this.hp++;
            floaters.push(new Floater(this.x, this.y - 20, "HEAL!", '#ff99cc'));
            AudioSys.playHeal();
            hudBounce = 1.2;
        } else {
            // Overheal score
            floaters.push(new Floater(this.x, this.y - 20, "BONUS!", '#ffff00'));
            AudioSys.playGem();
        }
    }

    takeDamage() {
        if (this.invincible > 0 || this.dead) return;
        this.hp--;
        this.invincible = 60;
        addShake(15);
        hudBounce = 0.9;
        AudioSys.playDamage();
        if (this.hp <= 0) {
            this.dead = true;
            gameOver();
        } else {
            this.vy = -5;
        }
    }

    draw(ctx) {
        if (this.dead) return;
        if (this.invincible > 0 && Math.floor(frameCount / 4) % 2 === 0) return;

        this.scarf.draw(ctx);

        // Guides
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - Math.cos(this.angle) * 150, this.y - Math.sin(this.angle) * 150);
        ctx.strokeStyle = CONFIG.colors.guideMove;
        ctx.lineWidth = 4;
        ctx.setLineDash([10, 10]);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scaleX, this.scaleY);
        ctx.rotate(this.angle + Math.PI/2); 

        // Body
        ctx.fillStyle = CONFIG.colors.player;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = CONFIG.colors.playerOutline;
        ctx.lineWidth = 3;
        ctx.stroke();

        // Goggles
        ctx.fillStyle = '#333';
        ctx.fillRect(-18, -4, 36, 6);
        ctx.fillStyle = '#ffaa00';
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(-7, -1, 6, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.arc(7, -1, 6, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(-9, -3, 2, 0, Math.PI*2); ctx.arc(5, -3, 2, 0, Math.PI*2); ctx.fill();

        ctx.restore();
    }
}

class Platform {
    constructor(x, y, w) {
        this.x = x; this.y = y; this.w = w; this.h = 24;
    }
    draw(ctx) {
        ctx.fillStyle = CONFIG.colors.platform;
        ctx.beginPath(); ctx.roundRect(this.x, this.y, this.w, this.h, 12); ctx.fill();
        ctx.fillStyle = '#ccffcc';
        ctx.beginPath(); ctx.roundRect(this.x, this.y, this.w, 8, 4); ctx.fill();
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath(); ctx.roundRect(this.x+5, this.y+this.h-8, this.w-10, 4, 2); ctx.fill();
    }
}

class HazardWall {
    constructor(x, y, w, h) {
        this.x = x; this.y = y; this.w = w; this.h = h;
    }
    draw(ctx) {
        ctx.fillStyle = '#440044';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        // Electric effect
        if (Math.floor(frameCount/5)%2 === 0) {
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(this.x+2, this.y+2, this.w-4, this.h-4);
        }
        ctx.strokeStyle = '#aa00aa';
        ctx.strokeRect(this.x, this.y, this.w, this.h);
        
        // Icon
        ctx.fillStyle = '#ff00ff';
        ctx.textAlign = 'center';
        ctx.font = '20px Arial';
        ctx.fillText("⚡", this.x + this.w/2, this.y + this.h/2 + 7);
    }
}

class Item {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'heart' or 'gem'
        this.vy = -4; // Pop up
        this.vx = (Math.random() - 0.5) * 4;
        this.life = 300; // 5 seconds
        this.angle = 0;
    }
    update() {
        this.vy += 0.2; // Gravity
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.95;
        this.life--;
        this.angle += 0.1;
    }
    draw(ctx) {
        if (this.life < 60 && Math.floor(this.life/4)%2===0) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        // Bobbing
        ctx.translate(0, Math.sin(this.life * 0.1) * 3);
        
        if (this.type === 'heart') {
            ctx.fillStyle = '#ff3366';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("❤", 0, 8);
        } else {
            ctx.fillStyle = '#00ffff';
            ctx.rotate(this.angle);
            ctx.fillRect(-6, -6, 12, 12);
        }
        ctx.restore();
    }
}

class Bullet {
    constructor(x, y, angle) {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * 14; this.vy = Math.sin(angle) * 14;
        this.life = 40;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw(ctx) {
        ctx.fillStyle = CONFIG.colors.bullet;
        ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill();
    }
}

class Enemy {
    constructor(y, type) {
        this.x = Math.random() * (width - 60) + 30;
        this.y = y;
        this.type = type; // 0: Normal, 1: Chaser, 2: Zigzag
        this.radius = 16;
        this.hp = 1;
        if (type === 1) this.hp = 2; // Chaser is tougher
        this.angle = 0;
        this.startX = this.x;
        this.startY = this.y;
        this.offset = Math.random() * 100;
        this.time = 0;
    }
    update(playerX, playerY) {
        this.time++;
        
        if (this.type === 0) {
            // Normal: Hover
            this.angle += 0.05;
            this.x = this.startX + Math.sin(this.angle * 2 + this.offset) * 60;
        } else if (this.type === 1) {
            // Chaser: Slowly move towards player
            const dx = playerX - this.x;
            const dy = playerY - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 300) { // Aggro range
                this.x += (dx / dist) * 1.5;
                this.y += (dy / dist) * 1.5;
            }
            this.angle += 0.1;
        } else if (this.type === 2) {
            // Zigzag: Fast horizontal
            this.x = this.startX + Math.sin(this.time * 0.1) * 120;
            this.y = this.startY + Math.cos(this.time * 0.05) * 30;
            this.angle -= 0.1;
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = (this.type === 1) ? CONFIG.colors.enemyChaser : CONFIG.colors.enemy;
        ctx.beginPath();
        const spikes = (this.type === 1) ? 12 : 8;
        for(let i=0; i<spikes; i++) {
            let rot = this.angle + (i * Math.PI * 2) / spikes;
            let r = (i%2===0) ? this.radius : this.radius * 0.6;
            ctx.lineTo(Math.cos(rot)*r, Math.sin(rot)*r);
        }
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, angle, type) {
        this.x = x; this.y = y; this.life = 1.0; this.type = type;
        const speed = (type === 'puff') ? 2 : 5;
        this.vx = (Math.random()-0.5)*speed; this.vy = (Math.random()-0.5)*speed;
        this.decay = (type === 'puff') ? 0.08 : 0.05;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life -= this.decay; }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = (this.type === 'puff') ? '#fff' : CONFIG.colors.enemy;
        ctx.beginPath(); ctx.arc(this.x, this.y, (this.type === 'puff') ? 8 : 4, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Floater {
    constructor(x, y, text, color) {
        this.x = x; this.y = y; this.text = text; this.life = 50; this.color = color || 'white';
    }
    update() { this.y -= 1; this.life--; }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life/50;
        ctx.font = 'bold 20px Verdana';
        ctx.textAlign = 'center';
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1;
    }
}

// --- GLOBALS ---
let player;
let bullets = [];
let enemies = [];
let platforms = [];
let hazards = [];
let items = [];
let particles = [];
let magmaY = 0;
let cameraY = 0;
let levelGenY = 0;

function addShake(amt) { shakeIntensity = Math.min(shakeIntensity + amt, 15); }

function saveHighScore() {
    if (Math.floor(maxAltitude) > highScore) {
        highScore = Math.floor(maxAltitude);
        localStorage.setItem('recoilJetHighAltitude', highScore);
        document.getElementById('high-score-display').innerText = `BEST: ${highScore}m`;
    }
}

function generateLevel() {
    while (levelGenY > cameraY - height * 2) {
        const gap = 110; 
        levelGenY -= gap; 
        
        const rand = Math.random();
        const w = 150 + Math.random() * 150;
        const x = Math.random() * (width - w);

        const currentHeight = Math.abs(levelGenY);
        let enemyChance = 0.4;
        let hazardChance = 0.2;

        if (currentHeight < 1000) { enemyChance = 0; hazardChance = 0; }

        if (rand < hazardChance) {
             // Spawn Hazard Wall
             hazards.push(new HazardWall(x, levelGenY, 100, 30));
        } else if (rand < hazardChance + enemyChance) {
             // Spawn Enemy (Random Type)
             let type = 0;
             if (currentHeight > 3000 && Math.random() > 0.7) type = 1; // Chaser
             if (currentHeight > 5000 && Math.random() > 0.5) type = 2; // Zigzag
             enemies.push(new Enemy(levelGenY, type));
        } else {
             platforms.push(new Platform(x, levelGenY, w));
        }
    }
    
    const delY = cameraY + height + 200;
    enemies = enemies.filter(e => e.y < delY);
    platforms = platforms.filter(p => p.y < delY);
    hazards = hazards.filter(h => h.y < delY);
    items = items.filter(i => i.y < delY);
}

function startGame() {
    AudioSys.init();
    player = new Player();
    bullets = [];
    enemies = [];
    platforms = [];
    hazards = [];
    items = [];
    particles = [];
    floaters = [];
    altitude = 0;
    maxAltitude = 0;
    frameCount = 0;
    magmaY = height + 800; 
    cameraY = 0;
    levelGenY = -200;
    hudBounce = 1.0;
    
    platforms.push(new Platform(width/2 - 100, height/2 + 100, 200));

    gameState = 'PLAY';
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('magma-warning').style.display = 'none';
    gameLoop();
}

function gameOver() {
    gameState = 'GAMEOVER';
    saveHighScore();
    AudioSys.playDamage();
    document.getElementById('start-screen').style.display = 'flex';
    document.querySelector('#start-screen h1').innerText = "GAME OVER";
    document.querySelector('#start-screen p').innerHTML = 
        `REACHED: ${Math.floor(maxAltitude)}m<br>BEST: ${highScore}m`;
}

function update() {
    if (hitStopFrames > 0) { hitStopFrames--; return; }

    // UI Bounce
    hudBounce += (1.0 - hudBounce) * 0.1;
    document.getElementById('hud-top').style.transform = `scale(${hudBounce})`;

    // Camera & Altitude
    const targetOffset = height * 0.7; 
    const targetCamY = player.y - targetOffset;
    cameraY += (targetCamY - cameraY) * CONFIG.cameraLerp;
    
    altitude = Math.abs(Math.min(0, player.y)) / 10;
    maxAltitude = Math.max(maxAltitude, altitude);

    // Faster Magma
    let magmaSpeed = CONFIG.magmaSpeedBase + (altitude / 5000); 
    if (player.y > magmaY - 300) magmaSpeed *= 0.5; // Mercy
    magmaY -= magmaSpeed;

    const dist = magmaY - player.y;
    const warn = document.getElementById('magma-warning');
    if (dist < 500 && !player.dead) {
        warn.style.display = 'block';
        warn.style.opacity = 1 - (dist/500);
    } else { warn.style.display = 'none'; }

    if (player.y > magmaY) { player.dead = true; gameOver(); }

    player.update();

    // Platforms
    player.grounded = false;
    platforms.forEach(p => {
        if (player.vy >= 0 &&
            player.y + player.radius >= p.y &&
            player.y - player.radius < p.y + p.h &&
            player.x > p.x && player.x < p.x + p.w)
        {
             if ((player.y + player.radius) - p.y < 30) { 
                 player.y = p.y - player.radius;
                 player.land();
             }
        }
    });

    // Hazards
    hazards.forEach(h => {
        if (player.x > h.x && player.x < h.x + h.w &&
            player.y > h.y && player.y < h.y + h.h) {
                player.takeDamage();
                player.vy = 10; // Knock down
        }
    });

    // Bullets vs Enemy
    bullets.forEach((b, i) => {
        b.update();
        if (b.life<=0) { bullets.splice(i,1); return; }
        
        for(let j=enemies.length-1; j>=0; j--) {
            let e = enemies[j];
            if (Math.hypot(b.x-e.x, b.y-e.y) < e.radius+10) {
                e.hp--;
                bullets.splice(i,1);
                AudioSys.playPop();
                if(e.hp<=0) {
                    enemies.splice(j,1);
                    hitStopFrames = 3;
                    for(let k=0; k<5; k++) particles.push(new Particle(e.x, e.y, 0, 'debris'));
                    
                    // DROP ITEM (30% Chance Heart, 20% Chance Gem)
                    const rand = Math.random();
                    if (rand < 0.3) {
                        items.push(new Item(e.x, e.y, 'heart'));
                    } else if (rand < 0.5) {
                        items.push(new Item(e.x, e.y, 'gem'));
                    }
                }
                break;
            }
        }
    });

    // Items Logic
    items.forEach((it, i) => {
        it.update();
        if (it.life <= 0) { items.splice(i, 1); return; }
        
        if (Math.hypot(player.x - it.x, player.y - it.y) < player.radius + 15) {
            if (it.type === 'heart') {
                player.heal();
            } else {
                floaters.push(new Floater(it.x, it.y - 20, "NICE!", '#00ffff'));
                AudioSys.playGem();
            }
            items.splice(i, 1);
        }
    });

    enemies.forEach(e => {
        e.update(player.x, player.y);
        if (Math.hypot(player.x-e.x, player.y-e.y) < player.radius + e.radius) {
            player.takeDamage();
            player.vx = (player.x - e.x) * 0.2;
            player.vy = -5;
        }
    });

    particles.forEach((p, i) => {
        p.update(); if(p.life<=0) particles.splice(i,1);
    });
    floaters.forEach((f, i) => {
        f.update(); if(f.life<=0) floaters.splice(i,1);
    });

    generateLevel();
    frameCount++;
}

function findNextTarget() {
    let best = null;
    let minDist = Infinity;
    platforms.forEach(p => {
        if (p.y < player.y - 50) {
            const dy = player.y - p.y;
            if (dy < minDist) { minDist = dy; best = p; }
        }
    });
    return best;
}

function draw() {
    ctx.fillStyle = CONFIG.colors.bg;
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    let shakeX = (Math.random()-0.5) * shakeIntensity;
    let shakeY = (Math.random()-0.5) * shakeIntensity;
    shakeIntensity *= 0.9;
    if (Math.abs(shakeIntensity)<0.5) shakeIntensity = 0;
    
    ctx.translate(shakeX, shakeY - cameraY);

    ctx.fillStyle = CONFIG.colors.magma;
    ctx.fillRect(0, magmaY, width, height*3);
    ctx.fillStyle = '#ffaa00';
    ctx.beginPath();
    for(let i=0; i<=width; i+=20) ctx.lineTo(i, magmaY + Math.sin(frameCount*0.2 + i*0.05)*15);
    ctx.lineTo(width, magmaY+50); ctx.lineTo(0, magmaY+50);
    ctx.fill();

    platforms.forEach(p => p.draw(ctx));
    hazards.forEach(h => h.draw(ctx));
    enemies.forEach(e => e.draw(ctx));
    items.forEach(i => i.draw(ctx));
    particles.forEach(p => p.draw(ctx));
    bullets.forEach(b => b.draw(ctx));
    player.draw(ctx);
    floaters.forEach(f => f.draw(ctx));

    const target = findNextTarget();
    if (target) {
        const tx = target.x + target.w / 2;
        const ty = target.y;
        const screenY = ty - cameraY;
        if (screenY < 0) {
            ctx.restore(); 
            ctx.save();
            const indicatorX = Math.max(20, Math.min(width-20, tx));
            ctx.translate(indicatorX, 30);
            ctx.translate(0, Math.sin(frameCount * 0.2) * 5);
            ctx.fillStyle = CONFIG.colors.marker;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-10, 10);
            ctx.lineTo(10, 10);
            ctx.fill();
            ctx.font = 'bold 12px Verdana';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.fillText("NEXT", 0, 25);
            ctx.restore();
            return; 
        }
    }

    ctx.restore();
    
    document.getElementById('altitude-display').innerText = `${Math.floor(altitude)}m`;
}

function gameLoop() {
    if (gameState === 'PLAY') {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }
}

ctx.fillStyle = '#222';
ctx.fillRect(0, 0, width, height);
</script>
</body>
</html>
